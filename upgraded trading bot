# -*- coding: utf-8 -*-
"""
Strategie: SMA Crossover (25/70) mit SL/TP Risikokontrolle
Asset: BTC-USD
Validierungsstatus: Walk-Forward & Out-of-Sample erfolgreich.
"""
import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import datetime
import warnings
warnings.filterwarnings("ignore")

# --- 1. GLOBALE KONFIGURATION & FINALE PARAMETER ---
# Die durch Walk-Forward und Optimierung gefundenen besten Parameter
TICKER = "BTC-USD" 
COST = 0.001       # 0.1% Transaktionskosten
BEST_FAST_SMA = 25
BEST_SLOW_SMA = 70
STOP_LOSS_PCT = 1.5 # 1.5% Stop-Loss
TAKE_PROFIT_PCT = 7.0 # 7.0% Take-Profit


# --- 2. HILFSFUNKTIONEN (METRIKEN) ---

def max_drawdown(returns):
    """Berechnet den maximalen Drawdown in Prozent."""
    cumulative = (1 + returns / 100).cumprod()
    peak = cumulative.expanding(min_periods=1).max()
    drawdown = (cumulative / peak) - 1
    return drawdown.min() * 100

def downside_deviation(returns):
    """Berechnet die Downside Deviation (Volatilität negativer Renditen)."""
    downside_returns = returns[returns < 0]
    if len(downside_returns) > 1:
        # Annualisierung: 252 ist die ungefähre Anzahl der Handelstage pro Jahr
        return downside_returns.std() * np.sqrt(252)
    return np.nan

def sharpe_ratio(returns):
    """Berechnet die annualisierte Sharpe Ratio (risikofreier Zinssatz = 0)."""
    annualized_return = returns.mean() * 252
    annualized_volatility = returns.std() * np.sqrt(252)
    if annualized_volatility == 0:
        return np.nan
    return annualized_return / annualized_volatility

def sortino_ratio(returns):
    """Berechnet die annualisierte Sortino Ratio."""
    annualized_return = returns.mean() * 252
    dd = downside_deviation(returns)
    if dd == 0 or np.isnan(dd):
        return np.nan
    return annualized_return / dd


# --- 3. DATENABRUF UND VORVERARBEITUNG ---

def preprocessing_yf(symbol, years=5):
    """Ruft Daten von Yahoo Finance ab und bereitet den DataFrame vor."""
    end_date = datetime.date.today()
    start_date = end_date - datetime.timedelta(days=years * 365)
    
    # Daten abrufen
    data = yf.download(symbol, start=start_date, end=end_date, progress=False).dropna()
    
    # DataFrame vorbereiten und Spaltennamen vereinheitlichen
    df = pd.DataFrame(data)
    
    # Korrigierte Spaltenbereinigung für yfinance
    df.columns = [
        '_'.join(map(str, col)).strip() if isinstance(col, tuple) else str(col) 
        for col in df.columns
    ]
    df.columns = [col.lower().replace(' ', '_') for col in df.columns]

    # Nur die relevanten Spalten zurückgeben
    return df[['open', 'high', 'low', 'close', 'volume']]


# --- 4. HAUPT-STRATEGIEFUNKTION (Mit SL/TP Simulation) ---

def SMA_strategy_full_risk_control(input_ticker, fast_sma, slow_sma, cost_ind, stop_loss_pct, take_profit_pct):
    """
    Simuliert die SMA Crossover Strategie mit täglicher Überprüfung von 
    Stop-Loss (SL) und Take-Profit (TP).
    """
    df = preprocessing_yf(input_ticker)
    
    # SMA Berechnung
    df["SMA fast"] = df["close"].rolling(fast_sma).mean()
    df["SMA slow"] = df["close"].rolling(slow_sma).mean()
    
    # Signale generieren
    df["signal"] = np.nan
    crossover_buy = (df["SMA fast"] > df["SMA slow"]) & (df["SMA fast"].shift(1) < df["SMA slow"].shift(1))
    crossover_sell = (df["SMA fast"] < df["SMA slow"]) & (df["SMA fast"].shift(1) > df["SMA slow"].shift(1))
    df.loc[crossover_buy, "signal"] = 1
    df.loc[crossover_sell, "signal"] = -1

    # Vorbereitung für die Simulation
    df["return"] = 0.0
    current_position = 0
    entry_price = np.nan

    sl_level = stop_loss_pct / 100
    tp_level = take_profit_pct / 100

    # Tag-für-Tag-Simulation
    for current_timestamp, row in df.iloc[1:].iterrows(): 

        current_index_pos = df.index.get_loc(current_timestamp)
        signal = row["signal"]

        # ----------------------------------------------------
        # A. Check für Stop-Loss ODER Take-Profit (Exit-Logik)
        # ----------------------------------------------------
        if current_position != 0 and entry_price is not np.nan:
            
            # --- Long Position ---
            if current_position == 1:
                profit = (row["high"] / entry_price) - 1
                drawdown = (row["low"] / entry_price) - 1

                if profit >= tp_level or drawdown < -sl_level:
                    # SL/TP ausgelöst. Gewinn/Verlust zum TP/SL-Level realisieren.
                    exit_return = tp_level if profit >= tp_level else -sl_level
                    df.loc[current_timestamp, "return"] = (exit_return * 100) - (cost_ind * 100)
                    current_position = 0
                    entry_price = np.nan
                    continue # Überspringe den Rest der Logik für diesen Tag

            # --- Short Position ---
            elif current_position == -1:
                profit = 1 - (row["low"] / entry_price) # Gewinn = Preis fällt
                run_up = (row["high"] / entry_price) - 1 # Verlust = Preis steigt

                if profit >= tp_level or run_up > sl_level:
                    # SL/TP ausgelöst
                    exit_return = tp_level if profit >= tp_level else -sl_level
                    df.loc[current_timestamp, "return"] = (exit_return * 100) - (cost_ind * 100)
                    current_position = 0
                    entry_price = np.nan
                    continue

        # ----------------------------------------------------
        # B. Berechne Tagesrendite (Intakter Trade)
        # ----------------------------------------------------
        if current_position != 0:
            previous_close = df.iloc[current_index_pos - 1]["close"]
            pct_change = row["close"] / previous_close - 1
            df.loc[current_timestamp, "return"] = (pct_change * current_position) * 100

        # ----------------------------------------------------
        # C. Check für Kreuzungssignal (Entry/Exit durch Crossover)
        # ----------------------------------------------------
        if signal != 0 and not np.isnan(signal):
            
            # 1. Exit durch Umkehrsignal
            if (signal == 1 and current_position == -1) or (signal == -1 and current_position == 1):
                df.loc[current_timestamp, "return"] -= cost_ind * 100
                current_position = 0
                entry_price = np.nan

            # 2. Entry für neuen Trade
            if signal != 0 and current_position == 0:
                current_position = signal
                entry_price = row["close"]
                df.loc[current_timestamp, "return"] -= cost_ind * 100 # Kosten beim Öffnen

    return df["return"]


# --- 5. FINALE AUSFÜHRUNG UND ERGEBNISSE ---

# Gesamte Strategie mit den finalen Parametern ausführen
final_returns = SMA_strategy_full_risk_control(
    TICKER, 
    BEST_FAST_SMA, 
    BEST_SLOW_SMA, 
    COST, 
    STOP_LOSS_PCT, 
    TAKE_PROFIT_PCT
)
final_returns_clean = final_returns.dropna()

# Performance-Kennzahlen berechnen
total_return = final_returns_clean.cumsum().iloc[-1]
sharpe = sharpe_ratio(final_returns_clean)
sortino = sortino_ratio(final_returns_clean)
drawdown = max_drawdown(final_returns_clean)

# Ausgabe der finalen Metriken
print("\n--- Final Validierte Strategie (Gesamtzeitraum) ---")
print(f"Asset: {TICKER} | Parameter: {BEST_FAST_SMA}/{BEST_SLOW_SMA} | SL {STOP_LOSS_PCT}% / TP {TAKE_PROFIT_PCT}%")
print(f"Gesamtrendite: {total_return:.2f}%")
print(f"Sharpe Ratio: {sharpe:.4f}")
print(f"Sortino Ratio: {sortino:.4f}")
print(f"Max Drawdown: {drawdown:.2f}%")

# Equity Curve plotten
plt.figure(figsize=(15, 8))
final_returns.cumsum().plot(
    title=f"Kumulierte Rendite: {TICKER} (SMA {BEST_FAST_SMA}/{BEST_SLOW_SMA} & SL/TP)",
    ylabel="P&L in %"
)
plt.show()

